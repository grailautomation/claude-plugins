{
  "tidbits": [
    {
      "tid": "2>&1",
      "bit": "`2>&1` is shell syntax that redirects **stderr** (file descriptor 2) to the same place as **stdout** (file descriptor 1).\n\nIn Unix-like systems, every process has three standard streams:\n- **0** = stdin (input)\n- **1** = stdout (standard output)\n- **2** = stderr (error output)\n\nSo `2>&1` means \"send file descriptor 2 to wherever file descriptor 1 is currently going.\"\n\n**Common usage:**\n\n```bash\n# Redirect both stdout and stderr to a file\ncommand > output.log 2>&1\n\n# Pipe both stdout and stderr to another command\ncommand 2>&1 | grep \"error\"\n\n# Discard all output (both stdout and stderr)\ncommand > /dev/null 2>&1\n```\n\n**Order matters:** The shell processes redirections left to right. In `command > file 2>&1`, stdout is first redirected to the file, then stderr is redirected to stdout (which now points to the file). If you wrote `command 2>&1 > file`, stderr would go to the terminal (where stdout originally pointed) while only stdout goes to the file.\n\n**Modern shorthand:** Bash also supports `&>` or `>&` as a shortcut for redirecting both streams:\n\n```bash\ncommand &> output.log   # equivalent to: command > output.log 2>&1\n```"
    },
    {
      "tid": "set -euo pipefail",
      "bit": "A common \"strict mode\" preamble for bash scripts that makes them fail fast on errors.\n\n```bash\n#!/usr/bin/env bash\nset -euo pipefail\n```\n\n**What each option does:**\n\n- **`-e`** (errexit): Exit immediately if any command returns a non-zero status\n- **`-u`** (nounset): Treat unset variables as an error and exit\n- **`-o pipefail`**: Return the exit status of the last command in a pipeline that failed (not just the last command)\n\n**Why use it:**\n\nWithout these options, bash scripts continue running even after errors, which can cause cascading failures or silent data corruption.\n\n**Example:**\n\n```bash\n# Without strict mode - silently continues after error\ncd /nonexistent/path\nrm -rf *  # This runs in the CURRENT directory!\n\n# With strict mode - stops at the cd failure\nset -euo pipefail\ncd /nonexistent/path  # Script exits here\nrm -rf *  # Never reached\n```\n\n**Caveats:**\n\n- Commands that are expected to fail need explicit handling: `command || true`\n- Use `${var:-default}` for variables that might be unset"
    },
    {
      "tid": "xargs",
      "bit": "`xargs` builds and executes command lines from standard input. It takes input (usually from a pipe) and converts it into arguments for another command.\n\n**Basic usage:**\n\n```bash\n# Delete all .tmp files\nfind . -name \"*.tmp\" | xargs rm\n\n# Same as running: rm file1.tmp file2.tmp file3.tmp ...\n```\n\n**Common flags:**\n\n- **`-I {}`**: Replace `{}` with each input item (one at a time)\n  ```bash\n  ls *.jpg | xargs -I {} mv {} /backup/\n  ```\n\n- **`-n N`**: Use at most N arguments per command\n  ```bash\n  echo 1 2 3 4 | xargs -n 2 echo\n  # Output: \"1 2\" then \"3 4\"\n  ```\n\n- **`-P N`**: Run N processes in parallel\n  ```bash\n  find . -name \"*.png\" | xargs -P 4 -I {} convert {} {}.webp\n  ```\n\n- **`-0`**: Use null character as delimiter (pairs with `find -print0`)\n  ```bash\n  # Safe handling of filenames with spaces\n  find . -name \"*.txt\" -print0 | xargs -0 rm\n  ```\n\n**Why not just backticks?**\n\n`xargs` handles arbitrarily long lists and avoids \"argument list too long\" errors that can occur with `$(...)` or backticks."
    },
    {
      "tid": "&&",
      "bit": "`&&` is the **AND operator** in shell - it runs the second command only if the first command succeeds (exit code 0).\n\n```bash\n# Only runs npm install if cd succeeds\ncd myproject && npm install\n\n# Chain multiple commands\nmkdir build && cd build && cmake .. && make\n```\n\n**Comparison with other operators:**\n\n| Operator | Meaning | Example |\n|----------|---------|--------|\n| `&&` | Run next if previous succeeds | `make && make install` |\n| `\\|\\|` | Run next if previous fails | `cmd \\|\\| echo \"failed\"` |\n| `;` | Run next regardless | `cmd1; cmd2` |\n| `\\|` | Pipe stdout to next command | `cat file \\| grep pattern` |\n\n**Common patterns:**\n\n```bash\n# Do something or exit with error\ncd /some/path || exit 1\n\n# Try primary, fall back to secondary\ncommand1 || command2\n\n# Conditional execution\n[ -f config.yml ] && source config.yml\n```"
    },
    {
      "tid": "chmod",
      "bit": "`chmod` changes file permissions. Permissions control who can read, write, or execute a file.\n\n**Numeric mode (octal):**\n\nEach digit represents: **owner / group / others**\n\nEach digit is sum of: **4 (read) + 2 (write) + 1 (execute)**\n\n```bash\nchmod 755 script.sh   # rwxr-xr-x (owner: all, others: read+execute)\nchmod 644 file.txt    # rw-r--r-- (owner: read+write, others: read)\nchmod 600 secret.key  # rw------- (owner only)\nchmod 777 open.txt    # rwxrwxrwx (everyone: all - rarely appropriate)\n```\n\n**Common permission values:**\n\n| Octal | Symbolic | Meaning |\n|-------|----------|--------|\n| 755 | rwxr-xr-x | Executable files, directories |\n| 644 | rw-r--r-- | Regular files |\n| 600 | rw------- | Private files (keys, configs) |\n| 700 | rwx------ | Private executables/directories |\n\n**Symbolic mode:**\n\n```bash\nchmod +x script.sh     # Add execute for everyone\nchmod u+x script.sh    # Add execute for user (owner) only\nchmod go-w file.txt    # Remove write from group and others\nchmod u=rw,go=r file   # Set explicit permissions\n```\n\n**Recursive:**\n\n```bash\nchmod -R 755 directory/   # Apply to directory and all contents\n```"
    },
    {
      "tid": "$?",
      "bit": "`$?` is a special variable that holds the **exit status** of the last executed command.\n\n- **0** = success\n- **Non-zero** = failure (specific codes vary by command)\n\n**Basic usage:**\n\n```bash\ngrep \"pattern\" file.txt\necho $?  # 0 if found, 1 if not found, 2 if error\n\nls /nonexistent\necho $?  # Non-zero (typically 1 or 2)\n```\n\n**Common patterns:**\n\n```bash\n# Check if command succeeded\nif [ $? -eq 0 ]; then\n    echo \"Success\"\nelse\n    echo \"Failed\"\nfi\n\n# More idiomatic - test command directly\nif grep -q \"pattern\" file.txt; then\n    echo \"Found\"\nfi\n\n# Capture exit status before it's overwritten\nsome_command\nstatus=$?\necho \"Logging...\"\nexit $status  # Exit with original status\n```\n\n**Common exit codes:**\n\n| Code | Meaning |\n|------|--------|\n| 0 | Success |\n| 1 | General error |\n| 2 | Misuse of command |\n| 126 | Permission denied |\n| 127 | Command not found |\n| 128+N | Killed by signal N |"
    },
    {
      "tid": "curl",
      "bit": "`curl` transfers data from or to a server. It's the Swiss Army knife for HTTP requests.\n\n**Basic requests:**\n\n```bash\n# GET request\ncurl https://api.example.com/data\n\n# POST with JSON\ncurl -X POST https://api.example.com/users \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\"name\": \"Alice\"}'\n\n# Download file\ncurl -O https://example.com/file.zip\ncurl -o myfile.zip https://example.com/file.zip\n```\n\n**Common flags:**\n\n| Flag | Purpose |\n|------|--------|\n| `-X METHOD` | HTTP method (GET, POST, PUT, DELETE) |\n| `-H \"Header: Value\"` | Add header |\n| `-d \"data\"` | Send data (implies POST) |\n| `-o file` | Output to file |\n| `-O` | Output to file (use remote filename) |\n| `-L` | Follow redirects |\n| `-s` | Silent (no progress) |\n| `-v` | Verbose (show headers) |\n| `-I` | HEAD request (headers only) |\n| `-u user:pass` | Basic authentication |\n| `-k` | Ignore SSL certificate errors |\n\n**Examples:**\n\n```bash\n# API with auth header\ncurl -H \"Authorization: Bearer $TOKEN\" https://api.example.com/me\n\n# Form submission\ncurl -X POST -d \"user=alice&pass=secret\" https://example.com/login\n\n# Upload file\ncurl -X POST -F \"file=@photo.jpg\" https://example.com/upload\n\n# Pretty-print JSON response\ncurl -s https://api.example.com/data | jq .\n```"
    },
    {
      "tid": "grep",
      "bit": "`grep` searches for patterns in text. It prints lines that match.\n\n**Basic usage:**\n\n```bash\ngrep \"pattern\" file.txt          # Search in file\ngrep \"pattern\" *.log             # Search in multiple files\ncat file.txt | grep \"pattern\"    # Search from stdin\n```\n\n**Common flags:**\n\n| Flag | Purpose |\n|------|--------|\n| `-i` | Case insensitive |\n| `-r` | Recursive (search directories) |\n| `-n` | Show line numbers |\n| `-l` | Show only filenames |\n| `-c` | Count matches |\n| `-v` | Invert match (lines NOT matching) |\n| `-w` | Match whole words only |\n| `-A N` | Show N lines after match |\n| `-B N` | Show N lines before match |\n| `-C N` | Show N lines before and after |\n| `-E` | Extended regex (or use `egrep`) |\n| `-o` | Show only the matching part |\n\n**Examples:**\n\n```bash\n# Find \"error\" case-insensitively with context\ngrep -i -C 2 \"error\" app.log\n\n# Find files containing pattern\ngrep -rl \"TODO\" src/\n\n# Count occurrences\ngrep -c \"function\" script.js\n\n# Extended regex\ngrep -E \"error|warning|fatal\" log.txt\n\n# Exclude certain files\ngrep -r \"pattern\" --exclude=\"*.min.js\" .\n```\n\n**Tip:** For faster searches in codebases, try `ripgrep` (`rg`) - same syntax, much faster."
    },
    {
      "tid": "/dev/null",
      "bit": "`/dev/null` is a special file that discards everything written to it. It's the \"black hole\" of Unix.\n\n**Common uses:**\n\n```bash\n# Discard stdout\ncommand > /dev/null\n\n# Discard stderr\ncommand 2> /dev/null\n\n# Discard both stdout and stderr\ncommand > /dev/null 2>&1\ncommand &> /dev/null  # Bash shorthand\n\n# Check if command exists (suppress output)\nif command -v git > /dev/null 2>&1; then\n    echo \"git is installed\"\nfi\n```\n\n**Why use it:**\n\n- Suppress noisy output you don't care about\n- Test if a command succeeds without seeing output\n- Prevent log spam in scripts\n- Provide empty input: `command < /dev/null`\n\n**Related special files:**\n\n| File | Purpose |\n|------|--------|\n| `/dev/null` | Discard output / provide empty input |\n| `/dev/zero` | Infinite stream of null bytes |\n| `/dev/random` | Random data (blocks when depleted) |\n| `/dev/urandom` | Random data (never blocks) |\n| `/dev/stdin` | Standard input |\n| `/dev/stdout` | Standard output |\n| `/dev/stderr` | Standard error |"
    },
    {
      "tid": "!!",
      "bit": "`!!` (\"bang bang\") is a bash history expansion that repeats the last command.\n\n**Most common use - run last command with sudo:**\n\n```bash\napt update\n# Permission denied\n\nsudo !!\n# Runs: sudo apt update\n```\n\n**Other history expansions:**\n\n| Syntax | Meaning |\n|--------|--------|\n| `!!` | Last command |\n| `!$` | Last argument of last command |\n| `!^` | First argument of last command |\n| `!*` | All arguments of last command |\n| `!n` | Command number n from history |\n| `!-n` | n commands ago |\n| `!string` | Most recent command starting with \"string\" |\n| `!?string` | Most recent command containing \"string\" |\n\n**Examples:**\n\n```bash\nmkdir /some/long/path\ncd !$              # cd /some/long/path\n\ncp file.txt backup/\nmv !^ elsewhere/   # mv file.txt elsewhere/\n\nvim config.yml\n!vim               # Runs last vim command\n```\n\n**Tip:** Use `Ctrl+P` or up arrow to recall and edit the last command instead - it's often safer than blind history expansion."
    }
  ]
}
